<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈深浅复制]]></title>
    <url>%2F2018%2F05%2F17%2F%E6%B7%B1%E6%B5%85%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[##浅谈深浅复制在开发过程中，我们常常会遇到对复杂对象中数据的复制。这时候就存在两种情况，一个是复制引用，一个是复制实例。这也就是浅复制和深复制。 ###什么是深度复制和浅度复制呢？深度复制和浅度复制都是针对像Array、Object等复杂对象而言的。对对象而言，浅复制是指是对对象地址的复制，没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变；而深复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 ###浅复制12345var testArray = [0,1,2]var copyArray = testArray;copyArray[0] = "change";console.log(copyArray); //输出["change", 1, 2]console.log(testArray); //输出["change", 1, 2] 由上面的例子可以看出，当改变复制数组中的值时，原来的数组值也会被改变。 ###深度复制深度复制情况比较复杂 ###1.slice()和concat()方法Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制，通过以下代码进行理解：12345678var array = [1,2,3];var array_shallow = array;var array_concat = array.concat();var array_slice = array.slice(0);array[0] = 2;console.log(array_shallow);//[2,2,3]console.log(array_concat);//[1,2,3]console.log(array_slice)//[1,2,3] 这里的复制只复制了一层，如果有多层属性的话，还是指向同一个内存地址，看下方的例子：1234567891011var array = [1, [1,2,3], &#123;name:"array"&#125;];var array_concat = array.concat();var array_slice = array.slice(0);//改变array_concat中数组元素的值array_concat[1][0] = 5;console.log(array[1]); //[5,2,3]console.log(array_slice[1]); //[5,2,3]//改变array_slice中对象元素的值array_slice[2].name = "array_slice";console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice 这里的例子可以看出不是真正的深度复制，只是对对象进行了引用 ###2.Object.assign()看下方的例子，相信你大概就明白了这个方法到底是深度复制还是浅复制12345var obj = &#123;a:1,b:2&#125;;var objclone = Object.assign(&#123;&#125;,obj);obj.c = 3;console.log(obj); //输出 &#123;a:1,b:2,c:3&#125;console.log(objclone); //输出&#123;a:1,b:2&#125; 再来一个~123456789101112let obj = &#123; a: 1, b: 2, c: &#123; age: 30 &#125;&#125;;var objclone = Object.assign(&#123;&#125;,obj);console.log('objclone: ', objclone);obj.c.age = 45;console.log('After Change - obj: ', obj.c.age); // 45 - This also changesconsole.log('After Change - objclone: ', objclone.c.age); // 45 所以Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。对于多层属性的复制，它也是属于浅复制。 ###3.JSON实现JSON对象下有两个方法，一是将JS对象转换成字符串对象的JSON.stringify方法；一个是将字符串对象转换成JS对象的JSON.parse方法。这两个方法结合使用可以实现对象的深复制。也就是说，当我们需要复制一个obj对象时，可以先调用JSON.stringify(obj)，将其转换为字符串对象，然后再调用JSON.parse方法，将其转换为JS对象。就可以轻松的实现对象的深复制看下方例子1234567891011var obj = &#123; a: 1, b: 2, c: &#123; age: 30 &#125;&#125;;var copyObject = JSON.parse(JSON.stringify(obj));copyObject.c.age = 45;console.log(obj) //obj=&#123;a:1,b:2,c:&#123;age:30&#125;&#125;console.log(copyObject) //copyObject=&#123;a:1,b:2,c:&#123;age:45&#125;&#125; 使用这种方式实现深复制有一个缺点就是必须给JSON.parse方法传入的字符串必须是合法的JSON，否则会抛出错误 ###4.采用递归解决123456789101112131415161718192021222324252627var testObject = &#123; a: 1, b: 2, c: &#123; age: 30 &#125;&#125;;function deepCopy(obj,copy)&#123; var copy = copy || &#123;&#125;; for(var i in obj)&#123; if(typeof obj[i] === 'object')&#123; //要考虑深复制问题了 if(obj[i].constructor === Array)&#123; copy[i] =[]; &#125;else&#123; copy[i] = &#123;&#125;; &#125; deepCopy(obj[i],copy[i]); &#125;else&#123; copy[i] = obj[i]; &#125; &#125; return copy;&#125;var copyObject = deepCopy(testObject);copyObject.c.age = 45;console.log(testObject) //&#123;a: 1,b: 2,c: &#123;age: 30&#125;&#125;; 这种方法的缺点是对于数据庞大的对象运行效率较低 以上是对深度复制和浅度复制的理解，如果有不对的地方欢迎指正哟，相互学习讨论~]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo 的基本命令]]></title>
    <url>%2F2017%2F12%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start新建文章1$ hexo new "My New Post" #文件名称 More info: Writing 开启预览访问端口1$ hexo server #默认端口4000 如默认端口被占用，则 1$ hexo s -p 5000 More info: Server 清除缓存，网页正常情况下可以忽略此条命令1$ hexo clean 生成静态页面至public目录1$ hexo generate More info: Generating 将.deploy目录部署到GitHub1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[变量/函数声明提升]]></title>
    <url>%2F2017%2F12%2F20%2Ffunction%2F</url>
    <content type="text"><![CDATA[此篇粗略的讲解下变量/函数声明提升。 什么是变量提升呢？正如字面意思，就是把定义在后面的变量或函数，提升到前面来使用。变量提升，简单来说，就是把定义的变量提升到一块作用域当中（或者说一个函数）顶端的位置，需要注意的是，变量提升，只是提示变量的声明，并不会将变量的赋值一同提升上来。 比如下面代码12345(function()&#123; var a = 1; var b = 2; var c = 3;&#125;)() 我们在函数中定义了3个变量，而实际上，相当于这种写法123456(function()&#123; var a,b,c； a = 1; b = 2; c = 3;&#125;)() 函数声明提升函数创建有两种方法函数声明语法：1234f('hello world!');function f(name) &#123; console.log(name);&#125; 运行上面的程序，控制台能打印出hello world! 函数表达式语法：1234f('hello world!');var f = function(name) &#123; console.log(name);&#125; 运行上面的代码，会报错Uncaught ReferenceError: f is not defined(…)错误信息，显示f没有被定义。因为，函数声明有一个非常重要的特征：函数声明提升，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部。正是因为这个特征，所以可以把函数声明刚在调用它的语句后面。1234567var getName = function()&#123; console.log(2);&#125;function getName()&#123; console.log(1);&#125;getName(); 正如前面所说到的函数声明提升，函数声明function getName(){}的声明会被提前到顶部，而函数表达式var getName = function(){}则表现出变量提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到顶部，而变量的赋值依然保留在原来的位置。相当于12345678var getName;function getName()&#123; console.log(1);&#125;getName = function()&#123; console.log(2);&#125;getName(); //最终输出2 在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出2.特别说明：函数提升会先于变量提升,看下面这个例子123console.log(typeof name)//输出functionvar name = "123";function name()&#123;&#125; 下面一题来测测你是否完全理解123456789101112131415function Foo()&#123; getName = function()&#123; alert(1) &#125;; return this;&#125;Foo.getName = function()&#123; alert(2) &#125;;Foo.prototype.getName = function()&#123; alert(3) &#125;;var getName = function()&#123; alert(4) &#125;;function getName()&#123; alert(5) &#125;;Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 答案1234567Foo.getName(); //2getName(); //4Foo().getName(); //1getName(); //1new Foo.getName(); //2new Foo().getName(); //3new new Foo().getName(); //3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[span间隙]]></title>
    <url>%2F2017%2F12%2F14%2Fspan%E9%97%B4%E9%9A%99%2F</url>
    <content type="text"><![CDATA[最近做移动端项目时，经常会碰到span元素之间存在诡异的间隙问题。这种间隙会导致一些布局上的问题，下面是几种解决的方法。 例子12345678&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123;display: inline-block; background-color: #ccc;&#125;&lt;/style&gt; 效果如下 在上述例子中，定义为inline-block的元素之间会产生间隙，那要是不定义为inline-block呢？12345678&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123; background-color: #ccc;&#125;&lt;/style&gt; 效果图 上面例子中，对span元素不做任何处理，依然会存在间隙，那如果把span元素放在一行显示会是怎么样的效果？123456&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123; background-color: #ccc;&#125;&lt;/style&gt; 效果图 可以发现，span元素之间的空隙消失了。说明这个间隙是由换行或者回车导致的，只要把标签写成一行就不会出现间隙，但是这种方法不太可靠，常常会因为一些因素失效。下面介绍一下几种写法：写法1：123&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 写法2：12345&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt; span元素&lt;/span&gt;&lt;span&gt; span元素&lt;/span&gt;&lt;/div&gt; 写法3：利用HTML注释标签12345&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 写法4：取消标签闭合12345&lt;div id="demo"&gt; &lt;span&gt;span元素 &lt;span&gt;span元素 &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 把span结束标签去掉，但需注意最后一个标签需要闭合。 写法5：把父级的font-size设为0,在子元素上设置相应的字体大小123456789&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo &#123;font-size:0;&#125; #demo span &#123; background-color: #ccc;font-size:14px;&#125;&lt;/style&gt; 对于Chrome, 其默认有最小字体大小限制，考虑到兼容性，需要取消字体大小限制，这样写：123456789&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo &#123;font-size:0;-webkit-text-size-adjust:none;&#125; #demo span &#123; background-color: #ccc;font-size:14px;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解決某些手机（移动端）无法触发touchend事件]]></title>
    <url>%2F2017%2F12%2F11%2Ftouch%2F</url>
    <content type="text"><![CDATA[开发移动端项目，虽然不用兼容头疼的IE浏览器，但是面对市场上各款手机兼容问题，也是一个持久战。这篇主要讲touch事件的兼容问题。 解決某些手机（移动端）无法触发touchend事件触屏事件的基本过程js的触屏事件，主要有三个事件：touchstart，touchmove，touchend。 这三个事件最重要的属性是 pageX和 pageY，表示X坐标，Y坐标。touchstart=在触摸开始时触发事件touchend=在触摸结束时触发事件touchmove=这个事件比较奇怪，按道理在触摸到过程中不断激发这个事件才对，但是在我的 Android 1.5 中，在 touchstart 激发后激发一次，然后剩余的都和 touchend 差不多同时激发。 而在我做的一个项目中，在某些手机上会出现不能触发touchend事件。 部分代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function listSlideChange(options) &#123; var delObj = options.find('.cheque-sign-row'), touchStartX = 0, touchMoveX = 0, touchSlideValue = 0, touchStartY = 0, touchMoveY = 0, touchSlideValue2 = 0, boxWidth = 0; for(var i = 0; i &lt; delObj.length; i++) &#123; (function(i) &#123; delObj.eq(i).off("touchstart.touch").on('touchstart.touch', function(e) &#123; moveFlag = false; var e = e || window.event; touchStartX = e.originalEvent.changedTouches[0].pageX; touchStartY = e.originalEvent.changedTouches[0].pageY; &#125;); delObj.eq(i).off("touchmove.touch").on('touchmove.touch', function(e) &#123; if ($(this).hasClass("disabled")) &#123; return false; &#125; var e = e || window.event; boxWidth = parseInt($('.transfer-plan-change').width()); var touchMoveX = e.originalEvent.changedTouches[0].pageX; touchSlideValue = touchStartX - touchMoveX; var touchMoveY = e.originalEvent.changedTouches[0].pageY; touchSlideValue2 = touchStartY - touchMoveY; if(Math.abs(touchSlideValue2)&lt;Math.abs(touchSlideValue))&#123; if(isSlideflag) &#123; $(delObj).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; &#125; else &#123; if(touchSlideValue &gt; 0 &amp;&amp; touchSlideValue &lt; boxWidth) &#123; $(this).css('left', -touchSlideValue); &#125; else if(touchSlideValue &gt; boxWidth) &#123; $(this).css('left', -boxWidth); &#125; else &#123; $(this).css('left', '0'); touchSlideValue = 0; &#125; &#125; moveFlag = true; &#125; &#125;); delObj.eq(i).off("touchend.touch").on('touchend.touch', function(e) &#123; if ($(this).hasClass("disabled")) &#123; return false; &#125; var e = e || window.event; if(moveFlag) &#123; if(touchSlideValue &gt; 60) &#123; $(this).stop().animate(&#123; 'left': -boxWidth &#125;, 200); isSlideflag = true; &#125; else &#123; $(this).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; isSlideflag = false; &#125; &#125; else &#123; if(touchSlideValue === 0) &#123; showChequeList($(this).find(".cheque-sign-arrow")); &#125; else &#123; $(delObj).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; isSlideflag = false; &#125; &#125; &#125;); &#125;)(i) &#125;&#125; 这是移动端最常见的功能，手指向左滑显示删除按钮。当你滑的比较少的距离，touchend时会隐藏这个删除按钮，只有你滑动到一定距离的时候，才会把整个删除按钮显示出来。而在某些手机上无法触发touchend事件，导致出现一半的按钮。 解决方法 只要在 touchstart 的时候调用下 event.preventDefault(); 即可让其他事件都正常被触发了!]]></content>
      <categories>
        <category>mobile</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[冒泡事件和默认事件]]></title>
    <url>%2F2017%2F02%2F16%2F%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[浅淡事件冒泡和默认事件 如何使用jQuery阻止事件冒泡和默认事件什么是事件冒泡？事件从事件目标开始，往上冒泡直到页面上的最上一级标签。（这与事件捕获顺序相反） 123456789101112131415161718&lt;div id="content"&gt; 外层div元素 &lt;span&gt;内层span元素&lt;/span&gt; 外层div元素&lt;/div&gt;&lt;div id="msg"&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $("#content").bind("click",function(e)&#123; var txt=$("#msg").html()+"&lt;p&gt;外层div元素被点击&lt;/p&gt;"; $("#msg").html(txt); &#125;); $("span").bind("click",function(e)&#123; var txt=$("#msg").html()+"&lt;p&gt;内层span元素被点击&lt;/p&gt;"; $("#msg").html(txt); &#125;);&#125;)&lt;/script&gt; 当点击span元素时会触发click事件,显示内层span元素被点击，同时因为事件冒泡，会触发content元素绑定的事件。 为什么要阻止事件冒泡呢？当某个DOM节点绑定了某事件监听器时，本来是想该DOM节点触发事件，才来执行某种操作。结果是该节点的某后代节点触发某事件，由于事件冒泡，该DOM节点事件也会触发，执行了该绑定事件的操作，这样就违背了最初的本意。 ###如何阻止事件冒泡？1234567891011121314&lt;style&gt; .box1&#123; height:200px; width:600px; margin:0 auto; border:1px solid #000; &#125; .box1 a&#123; display:block; height:50%; width:50%; background:red; &#125;&lt;/style&gt; 123456789101112&lt;body&gt; &lt;div class="box1"&gt; &lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1");//不阻止事件冒泡会打印1 ，页面跳转 &#125;) &#125;)&lt;/script&gt; 当点击a元素时，触发a本身的事件，同时也会触发父级绑定的click事件 12345678910&lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; e.stopPropagation();//不会打印a,但是页面会跳转 &#125;) &#125;)&lt;/script&gt; 阻止了冒泡事件，点击a元素时，不会触发父级box1的绑定事件。但是会执行a的默认事件（跳转到百度页面） 12345678910 &lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; e.preventDefault();//页面不会跳转，但是会打印出1 &#125;) &#125;)&lt;/script&gt; 阻止了a的默认事件，页面不会跳转，但是会触发父级的绑定事件 12345678910&lt;script&gt;$(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; return false;//不会打印1,页面不会跳转 &#125;)&#125;)&lt;/script&gt; 同时阻止了冒泡事件和默认事件，你也可以把return false替换成e.preventDefault()和e.stopPropagation();]]></content>
      <categories>
        <category>jquery</category>
      </categories>
  </entry>
</search>
