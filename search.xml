<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[splice, slice, substring, substr]]></title>
    <url>%2F2019%2F02%2F17%2Fsplice%2C%20slice%2C%20substring%2C%20substr%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[splice, slice, substring, substr等方法的一些区别 今天来写写这些个方法的区别，平时在工作中总是傻傻分不清楚，写篇笔记留着查看。 1.splice()方法定义：splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。注意： 该方法会改变原始数组。用法： 1arr.splice(index, howmany, item1, ....itemN) index: 必需。整数，规定添加/删除项目的下标，使用负数可从数组结尾处规定位置。howmany: 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item: 可选。要添加的元素 例子 123var arr = [1,2,3,4,5]console.log(arr.splice(0,1,2)); //[1]console.log(arr); //[2,2,3,4,5] 2.slice()方法定义：slice()方法可从已有的数组中返回选定的元素。注意： 该方法不会改变原始数组。用法： 1arr.slice(start,end) start: 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end: 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 例子 123var arr = [1,2,3,4];console.log(arr.slice(1, 3)); //[2, 3]console.log(arr); //[1,2,3,4] 3.substring()方法定义： substring() 方法用于提取字符串中介于两个指定下标之间的字符。注意： 该方法不会改变原始字符串。重要事项：与 slice() 和 substr() 方法不同的是，substring() 不接受负的参数。用法： 1str.substring(start,stop) start: 必需。一个非负的整数，规定要提取的子串的第一个字符在 str 中的位置。end: 可选。一个非负的整数，比要提取的子串的最后一个字符在 str中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。 例子 12345var str="Hello world!";console.log(str.substring(3)); //'lo world!'console.log(str.substring(3,8)); //'lo wo'console.log(str.substring(5,1)); //'ello 'console.log(str); //'Hello world!' substr()方法定义： substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。注意： 该方法不会改变原始字符串。注释：substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice() 来使用。用法： 1str.substr(start,length) start: 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。length: 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 str的开始位置到结尾的字串。例子 12345var str="Hello world!"；console.log(str.substr(3)); //'lo world!'console.log(str.substr(-1)); //'!'console.log(str.substr(1,7)); //'ello wo'console.log(str); //'Hello world!']]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[容易出错的JavaScript题目集锦]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%9C%89%E8%B6%A3%E7%9A%84JavaScript%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[容易出错的JavaScript题目集锦 1.typeof(null) 会得到什么？object,在JavaScript中null被认为是一个对象。 2.下列代码将输出控制台的是什么？为什么？123456(function()&#123; var a = b = 3;&#125;)();console.log("a defined? " + (typeof a !== 'undefined'));console.log("b defined? " + (typeof b !== 'undefined')); 由于a和b都在函数的封闭范围内定义，并且由于它们所在的行以var关键字开头,因此大多数JavaScript开发人员会希望typeof a和typeof b在上面的示例中都未定义。但是，情况并非如此。这里的问题是大多数开发人员错误地理解语句var a = b = 3;以下简写为：12var b = 3;var a = b; 但实际上，var a = b = 3;其实是速记：12b = 3;var a = b; 因此（如果您不使用严格模式），代码片段的输出将为：12a defined? falseb defined? true 但是如何在封闭函数的范围之外定义b？那么，因为声明var a = b = 3;是语句b = 3的简写;并且var a = b;b最终成为一个全局变量（因为它不在var关键字后面），因此它仍然在作用域内，即使在封闭函数之外。 注意，在严格模式下（即，使用strict），语句var a = b = 3;会产生一个ReferenceError的运行时错误：b没有定义，从而避免了可能导致的任何头headfakes/bugs。 （这就是为什么你应该在你的代码中使用strict，一个重要的例子！） 3.下面的代码将输出到控制台的是什么？，为什么？12345678910111213var myObject = &#123; foo: "bar", func: function() &#123; var self = this; console.log("outer func: this.foo = " + this.foo); console.log("outer func: self.foo = " + self.foo); (function() &#123; console.log("inner func: this.foo = " + this.foo); console.log("inner func: self.foo = " + self.foo); &#125;()); &#125;&#125;;myObject.func(); 在控制台将会输出如下结果1234outer func: this.foo = barouter func: self.foo = barinner func: this.foo = undefinedinner func: self.foo = bar 在外面函数中self和this都指向myObject,因此都能访问到myObject中的foo属性。在内部函数中，此时this的指向已经是window，而window中没有foo属性，所以为undefined。 4.考虑下面的两个函数。他们都会返回同样的值吗？为什么或者为什么不？123456789101112function foo1()&#123; return &#123; bar: "hello" &#125;;&#125;function foo2()&#123; return &#123; bar: "hello" &#125;;&#125; 令人惊讶的是，这两个函数不会返回相同的结果。而是：1234console.log("foo1 returns:");console.log(foo1());console.log("foo2 returns:");console.log(foo2()); 1234foo1 returns:Object &#123;bar: "hello"&#125;foo2 returns:undefined 这不仅令人惊讶，而且特别令人烦恼的是，foo2()返回未定义而没有引发任何错误。原因与JavaScript中分号在技术上是可选的事实有关（尽管忽略它们通常是非常糟糕的形式）。因此，在foo2()中遇到包含return语句的行（没有其他内容）时，会在return语句之后立即自动插入分号。由于代码的其余部分是完全有效的，即使它没有被调用或做任何事情（它只是一个未使用的代码块，它定义了一个属性栏，它等于字符串“hello”），所以不会抛出任何错误。这种行为也被认为是遵循了在JavaScript中将一行开头大括号放在行尾的约定，而不是在新行的开头。如此处所示，这不仅仅是JavaScript中的一种风格偏好。 5.下面的代码输出什么？解释你的答案。12console.log(0.1 + 0.2);console.log(0.1 + 0.2 == 0.3); 上面提供的示例是演示此问题的经典案例。令人惊讶的是，它会打印出来：120.30000000000000004false 一个典型的解决方案是比较两个数字与特殊常数Number.EPSILON之间的绝对差值：1234function areTheNumbersAlmostEqual(num1, num2) &#123; return Math.abs( num1 - num2 ) &lt; Number.EPSILON;&#125;console.log(areTheNumbersAlmostEqual(0.1 + 0.2, 0.3)); Math.abs()是取得数据的绝对值，Number.EPSILON 属性表示 1 和大于 1 的最小值（可表示为 Number）的差值。 6.编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是回文。如果str是回文，以下一行函数将返回true;否则，它返回false。1234function isPalindrome(str) &#123; str = str.replace(/\W/g, '').toLowerCase(); return (str == str.split('').reverse().join(''));&#125; 123console.log(isPalindrome("level")); // 'true'console.log(isPalindrome("levels")); // 'false'console.log(isPalindrome("A car, a man, a maraca")); // 'true' 7.考虑下面的代码片段123456for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); btn.addEventListener('click', function()&#123; console.log(i); &#125;); document.body.appendChild(btn);&#125; (a) 当用户点击“按钮4”时，什么被记录到控制台？为什么？(b) 提供一个或多个可按预期工作的替代实现。答：(a) 无论用户点击哪个按钮，数字5将始终记录到控制台。这是因为，在调用onclick方法（对于任何按钮）时，for循环已经完成，并且变量i已经具有值5.（如果受访者知道足够的话就可以获得奖励点数关于执行上下文，变量对象，激活对象和内部“范围”属性如何影响闭包行为。）(b) 使这项工作的关键是通过将它传递给新创建的函数对象来捕获每次通过for循环的i的值。以下是四种可能的方法来实现这一点：12345678910for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); btn.addEventListener('click', (function(i)&#123; return function()&#123; console.log(i) &#125; &#125;)(i)); document.body.appendChild(btn);&#125; 或者，您可以将新的匿名函数中的整个调用包装为btn.addEventListener：12345678910for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); (function(i)&#123; btn.addEventListener("click",function()&#123; console.log(i) &#125;) &#125;)(i) document.body.appendChild(btn);&#125; 最后，最简单的解决方案，如果你在ES6 / ES2015上下文中，就是使用let i而不是var i：123456for (let i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); btn.addEventListener('click', function()&#123; console.log(i); &#125;); document.body.appendChild(btn);&#125; 8.下面的代码将输出到控制台,输出结果是什么？123456console.log(1 + "2" + "2");console.log(1 + +"2" + "2");console.log(1 + -"1" + "2");console.log(+"1" + "1" + "2");console.log( "A" - "B" + "2");console.log( "A" - "B" + 2); 输出的结果为：123456"122""32""02""112""NaN2""NaN" 这里的基本问题是JavaScript（ECMAScript）是一种松散类型的语言，它对值执行自动类型转换以适应正在执行的操作。让我们来看看这是如何与上面的每个例子进行比较。示例1：1 +“2”+“2”输出：“122”说明：第一个操作在1 +“2”中执行。由于其中一个操作数（“2”）是一个字符串，所以JavaScript假定需要执行字符串连接，因此将1的类型转换为“1”，1 +“2”转换为“12”。然后，“12”+“2”产生“122”。示例2：1 + +“2”+“2”输出：“32”说明：根据操作顺序，要执行的第一个操作是+“2”（第一个“2”之前的额外+被视为一个一元运算符）。因此，JavaScript将“2”的类型转换为数字，然后将一元+符号应用于它（即将其视为正数）。结果，下一个操作现在是1 + 2，当然这会产生3.但是，我们有一个数字和一个字符串之间的操作（即3和“2”），所以JavaScript再次转换数值赋给一个字符串并执行字符串连接，产生“32”。示例3：1 + - “1”+“2”输出：“02”说明：这里的解释与前面的示例相同，只是一元运算符是 - 而不是+。因此，“1”变为1，然后在应用 - 时将其变为-1，然后将其加1到产生0，然后转换为字符串并与最终的“2”操作数连接，产生“02”。示例4：+“1”+“1”+“2”输出：“112”说明：尽管第一个“1”操作数是基于其前面的一元+运算符的数值类型转换的，当它与第二个“1”操作数连接在一起时返回一个字符串，然后与最终的“2”操作数连接，产生字符串“112”。示例5：“A” - “B”+“2”输出：“NaN2”说明：由于 - 运算符不能应用于字符串，并且既不能将“A”也不能将“B”转换为数值， “ - ”B“产生NaN，然后与字符串”2“串联产生”NaN2“。例6：“A” - “B”+2输出：NaN说明：在前面的例子中，“A” - “B”产生NaN。但是任何运算符应用于NaN和其他数字操作数仍然会产生NaN。 9.以下代码的输出是什么：123for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );&#125; 显示的代码示例不会显示值0,1,2,3和4，这可能是预期的;而是显示5,5,5,5,5。这是因为循环内执行的每个函数将在整个循环完成后执行，因此所有函数都会引用存储在i中的最后一个值，即5。通过为每次迭代创建一个唯一的作用域，可以使用闭包来防止这个问题，并将该变量的每个唯一值存储在其作用域中，如下所示：12345for (var i = 0; i &lt; 5; i++) &#123; (function(i)&#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i)&#125; 在ES2015上下文中，您可以在原始代码中简单地使用let而不是var：123for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );&#125; 10.以下代码的输出是什么？解释你的答案。12345678var a=&#123;&#125;, b=&#123;key:'b'&#125;, c=&#123;key:'c'&#125;;a[b]=123;a[c]=456;console.log(a[b]); 此代码的输出将是456（不是123）。原因如下：设置对象属性时，JavaScript会隐式地将参数值串联起来。在这种情况下，由于b和c都是对象，它们都将被转换为“[object Object]”。因此，a [b]和a [c]都等价于[“[object Object]”]，并且可以互换使用。因此，设置或引用[c]与设置或引用[b]完全相同。 11.以下代码将输出到控制台以及为什么1234567891011var hero = &#123; _name: 'John Doe', getSecretIdentity: function ()&#123; return this._name; &#125;&#125;;var stoleSecretIdentity = hero.getSecretIdentity;console.log(stoleSecretIdentity());console.log(hero.getSecretIdentity()); 这段代码有什么问题，以及如何解决这个问题。该代码将输出：12undefinedJohn Doe 第一个console.log打印未定义，因为我们从hero对象中提取方法，所以stoleSecretIdentity()在window上下文的执行环境中被调用，而window中没有定义_name属性，所以为underfined。 修复stoleSecretIdentity()函数的一种方法如下：1234567891011var hero = &#123; _name: 'John Doe', getSecretIdentity: function ()&#123; return this._name; &#125;&#125;;var stoleSecretIdentity = hero.getSecretIdentity.bind(hero);console.log(stoleSecretIdentity());console.log(hero.getSecretIdentity()); 12.以下输出的是什么？1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); 输出：12102 为什么不是10和5？ 首先，由于fn作为函数方法的参数传递，函数fn的作用域（this）是窗口。 var length = 10;在窗口级别声明。它也可以作为window.length或length或this.length来访问（当这个===窗口时）。 方法绑定到Object obj，obj.method用参数fn和1调用。虽然方法只接受一个参数，但调用它时已经传递了两个参数;第一个是函数回调，其他只是一个数字。 当在内部方法中调用fn()时，该函数在全局级别作为参数传递，this.length将有权访问在Object obj中定义的var length = 10（全局声明）而不是length = 5。 现在，我们知道我们可以使用arguments []数组访问JavaScript函数中的任意数量的参数。 因此arguments0只不过是调用fn()。在fn里面，这个函数的作用域成为参数数组，并且记录参数[]的长度将返回2。 13.考虑下面的代码。输出是什么，为什么？12345678910111213(function () &#123; try &#123; throw new Error(); &#125; catch (x) &#123; var x = 1, y = 2; console.log(x); &#125; console.log(x); console.log(y);&#125;)();1undefined2 var语句被挂起（没有它们的值初始化）到它所属的全局或函数作用域的顶部，即使它位于with或catch块内。但是，错误的标识符只在catch块内部可见。它相当于：123456789101112(function () &#123; var x, y; // outer and hoisted try &#123; throw new Error(); &#125; catch (x /* inner */) &#123; x = 1; // inner x, not the outer one y = 2; // there is only one y, which is in the outer scope console.log(x /* inner */); &#125; console.log(x); console.log(y);&#125;)(); 14.以下几行输出什么，为什么？12console.log(1 &lt; 2 &lt; 3);console.log(3 &gt; 2 &gt; 1); 第一条语句返回true，如预期的那样。 第二个返回false是因为引擎如何针对&lt;和&gt;的操作符关联性工作。它比较从左到右，所以3&gt; 2&gt; 1 JavaScript翻译为true&gt; 1. true具有值1，因此它比较1&gt; 1，这是错误的。 15.如何在数组的开头添加元素？最后如何添加一个？1234var myArray = ['a', 'b', 'c', 'd'];myArray.push('end');myArray.unshift('start');console.log(myArray); // ["start", "a", "b", "c", "d", "end"] 使用ES6，可以使用扩展运算符：12myArray = ['start', ...myArray];myArray = [...myArray, 'end']; 或者，简而言之：1myArray = ['start', ...myArray, 'end']; 15.代码返回后会怎么样？1console.log(typeof typeof 1); 打印结果：stringtypeof 1将返回“number”，typeof“number”将返回字符串。 16.以下代码输出什么？为什么？1234567891011var b = 1;function outer()&#123; var b = 2 function inner()&#123; b++; var b = 3; console.log(b) &#125; inner();&#125;outer(); 输出到控制台将是“3”。 在这个例子中有三个闭包，每个都有它自己的var b声明。当调用变量时，将按照从本地到全局的顺序检查闭包，直到找到实例。由于内部闭包有自己的b变量，这就是输出。 此外，由于提升内部的代码将被解释如下：123456function inner () &#123; var b; // b is undefined b++; // b is NaN b = 3; // b is 3 console.log(b); // output "3"&#125; 以上来自于xiaosheng222 17.以下代码输出什么？1234567var animal = function()&#123;&#125;;var dog = function()&#123;&#125;; animal.price = 2000;dog.prototype = animal; var tiddy = new dog();alert(dog.price);/*underfined*/alert(tiddy.price);/*2000*/ 因为原型链是依赖于proto，而不是prototype。dog是函数对象，本身没有price属性，此时dog的proto属性指向的是其构造函数的原型。 dog的构造函数就是Function，因为var dog = function(){};语句实际上是var dog = new Function();，所以，dog.proto === Function.prototype；⽽而Function.prototype并没有price属性，如果加一句：Function.prototype.price = 123；那么第一个打印就是123；如此依赖，tidy是一个普通对象，由dog函数构造而来，因此tidyproto == dog.prototype == animal；所以当tidy上找不到price属性时，会从proto寻找原型上的方法，找到animal对象， animal对象有price属性，则返回。 18.以下题目弹出的值是多少？123456var a=b=0; var c=d=&#123;x:1&#125;; b = 1;d.x = 1; alert("a的值为："+a+" b的值为:"+b);alert("c.x的值为："+c.x+" d.x的值为:"+d.x); 弹出的结果为：12a的值为：0 b的值为：1c.x的值为：1 d.x的值为：1 此题考查的是基本类型和引用类型 a 声明变量时不同的内存分配。1） 原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。2） 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是⼀一个指针（point），指向存储对象的内存地址。 19.以下代码执行结果是多少？1234567if(1 == "1")&#123; var x = 1;&#125;else &#123; var z = 1;&#125; console.log(x);console.log(z); 由于变量提升的缘故，相当于123456789var x;var z;if(1 == "1")&#123; x = 1;&#125;else &#123; z = 1;&#125;console.log(x);console.log(z); 所以输出结果x为1，z为undefined 20.如何使数组去重?12345678var arr = [1,2,3,4,3,2,2,1];var newArr = [];for(var i=0; i&lt;arr.length;i++)&#123; if(newArr.indexOf(arr[i]) == -1)&#123; newArr.push(arr[i]) &#125;&#125; console.log(newArr) 21.如何返回一个字符串中出现次数多的字母12345678910111213141516171819202122232425var str = "absbdsbdudbsu";function count(str)&#123; if(str.length == 1)&#123; return str; &#125;else &#123; var wordNum = &#123;&#125;; for(var i=0;i&lt;str.length;i++)&#123; if(!wordNum[str.charAt(i)])&#123; wordNum[str.charAt(i)] = 1; &#125;else &#123; wordNum[str.charAt(i)]++; &#125; &#125; var wordMax = '', max = 0; for(var i in wordNum)&#123; if(wordNum[i]&gt;max)&#123; wordMax = i; max = wordNum[i] &#125; &#125; return wordMax &#125; &#125; console.log(count(str))]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈深浅复制]]></title>
    <url>%2F2018%2F05%2F17%2Fclone%2F</url>
    <content type="text"><![CDATA[浅谈深浅复制在开发过程中，我们常常会遇到对复杂对象中数据的复制。这时候就存在两种情况，一个是复制引用，一个是复制实例。这也就是浅复制和深复制。 什么是深度复制和浅度复制呢？深度复制和浅度复制都是针对像Array、Object等复杂对象而言的。对对象而言，浅复制是指是对对象地址的复制，没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变；而深复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 浅复制12345var testArray = [0,1,2]var copyArray = testArray;copyArray[0] = "change";console.log(copyArray); //输出["change", 1, 2]console.log(testArray); //输出["change", 1, 2] 由上面的例子可以看出，当改变复制数组中的值时，原来的数组值也会被改变。 深度复制深度复制情况比较复杂 1.slice()和concat()方法Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制，通过以下代码进行理解：12345678var array = [1,2,3];var array_shallow = array;var array_concat = array.concat();var array_slice = array.slice(0);array[0] = 2;console.log(array_shallow);//[2,2,3]console.log(array_concat);//[1,2,3]console.log(array_slice)//[1,2,3] 这里的复制只复制了一层，如果有多层属性的话，还是指向同一个内存地址，看下方的例子：1234567891011var array = [1, [1,2,3], &#123;name:"array"&#125;];var array_concat = array.concat();var array_slice = array.slice(0);//改变array_concat中数组元素的值array_concat[1][0] = 5;console.log(array[1]); //[5,2,3]console.log(array_slice[1]); //[5,2,3]//改变array_slice中对象元素的值array_slice[2].name = "array_slice";console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice 这里的例子可以看出不是真正的深度复制，只是对对象进行了引用 2.Object.assign()看下方的例子，相信你大概就明白了这个方法到底是深度复制还是浅复制12345var obj = &#123;a:1,b:2&#125;;var objclone = Object.assign(&#123;&#125;,obj);obj.c = 3;console.log(obj); //输出 &#123;a:1,b:2,c:3&#125;console.log(objclone); //输出&#123;a:1,b:2&#125; 再来一个~123456789101112let obj = &#123; a: 1, b: 2, c: &#123; age: 30 &#125;&#125;;var objclone = Object.assign(&#123;&#125;,obj);console.log('objclone: ', objclone);obj.c.age = 45;console.log('After Change - obj: ', obj.c.age); // 45 - This also changesconsole.log('After Change - objclone: ', objclone.c.age); // 45 所以Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。对于多层属性的复制，它也是属于浅复制。 3.JSON实现JSON对象下有两个方法，一是将JS对象转换成字符串对象的JSON.stringify方法；一个是将字符串对象转换成JS对象的JSON.parse方法。这两个方法结合使用可以实现对象的深复制。也就是说，当我们需要复制一个obj对象时，可以先调用JSON.stringify(obj)，将其转换为字符串对象，然后再调用JSON.parse方法，将其转换为JS对象。就可以轻松的实现对象的深复制看下方例子1234567891011var obj = &#123; a: 1, b: 2, c: &#123; age: 30 &#125;&#125;;var copyObject = JSON.parse(JSON.stringify(obj));copyObject.c.age = 45;console.log(obj) //obj=&#123;a:1,b:2,c:&#123;age:30&#125;&#125;console.log(copyObject) //copyObject=&#123;a:1,b:2,c:&#123;age:45&#125;&#125; 使用这种方式实现深复制有一个缺点就是必须给JSON.parse方法传入的字符串必须是合法的JSON，否则会抛出错误 4.采用递归解决123456789101112131415161718192021222324252627var testObject = &#123; a: 1, b: 2, c: &#123; age: 30 &#125;&#125;;function deepCopy(obj,copy)&#123; var copy = copy || &#123;&#125;; for(var i in obj)&#123; if(typeof obj[i] === 'object')&#123; //要考虑深复制问题了 if(obj[i].constructor === Array)&#123; copy[i] =[]; &#125;else&#123; copy[i] = &#123;&#125;; &#125; deepCopy(obj[i],copy[i]); &#125;else&#123; copy[i] = obj[i]; &#125; &#125; return copy;&#125;var copyObject = deepCopy(testObject);copyObject.c.age = 45;console.log(testObject) //&#123;a: 1,b: 2,c: &#123;age: 30&#125;&#125;; 这种方法的缺点是对于数据庞大的对象运行效率较低 以上是对深度复制和浅度复制的理解，如果有不对的地方欢迎指正哟，相互学习讨论~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo 的基本命令]]></title>
    <url>%2F2017%2F12%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start新建文章1$ hexo new "My New Post" #文件名称 More info: Writing 开启预览访问端口1$ hexo server #默认端口4000 如默认端口被占用，则 1$ hexo s -p 5000 More info: Server 清除缓存，网页正常情况下可以忽略此条命令1$ hexo clean 生成静态页面至public目录1$ hexo generate More info: Generating 将.deploy目录部署到GitHub1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[变量/函数声明提升]]></title>
    <url>%2F2017%2F12%2F20%2Ffunction%2F</url>
    <content type="text"><![CDATA[此篇粗略的讲解下变量/函数声明提升。 什么是变量提升呢？正如字面意思，就是把定义在后面的变量或函数，提升到前面来使用。变量提升，简单来说，就是把定义的变量提升到一块作用域当中（或者说一个函数）顶端的位置，需要注意的是，变量提升，只是提示变量的声明，并不会将变量的赋值一同提升上来。 比如下面代码12345(function()&#123; var a = 1; var b = 2; var c = 3;&#125;)() 我们在函数中定义了3个变量，而实际上，相当于这种写法123456(function()&#123; var a,b,c； a = 1; b = 2; c = 3;&#125;)() 函数声明提升函数创建有两种方法函数声明语法：1234f('hello world!');function f(name) &#123; console.log(name);&#125; 运行上面的程序，控制台能打印出hello world! 函数表达式语法：1234f('hello world!');var f = function(name) &#123; console.log(name);&#125; 运行上面的代码，会报错Uncaught ReferenceError: f is not defined(…)错误信息，显示f没有被定义。因为，函数声明有一个非常重要的特征：函数声明提升，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部。正是因为这个特征，所以可以把函数声明刚在调用它的语句后面。1234567var getName = function()&#123; console.log(2);&#125;function getName()&#123; console.log(1);&#125;getName(); 正如前面所说到的函数声明提升，函数声明function getName(){}的声明会被提前到顶部，而函数表达式var getName = function(){}则表现出变量提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到顶部，而变量的赋值依然保留在原来的位置。相当于12345678var getName;function getName()&#123; console.log(1);&#125;getName = function()&#123; console.log(2);&#125;getName(); //最终输出2 在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出2.特别说明：函数提升会先于变量提升,看下面这个例子123console.log(typeof name)//输出functionvar name = "123";function name()&#123;&#125; 下面一题来测测你是否完全理解123456789101112131415function Foo()&#123; getName = function()&#123; alert(1) &#125;; return this;&#125;Foo.getName = function()&#123; alert(2) &#125;;Foo.prototype.getName = function()&#123; alert(3) &#125;;var getName = function()&#123; alert(4) &#125;;function getName()&#123; alert(5) &#125;;Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 答案1234567Foo.getName(); //2getName(); //4Foo().getName(); //1getName(); //1new Foo.getName(); //2new Foo().getName(); //3new new Foo().getName(); //3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[span间隙]]></title>
    <url>%2F2017%2F12%2F14%2Fspan%E9%97%B4%E9%9A%99%2F</url>
    <content type="text"><![CDATA[最近做移动端项目时，经常会碰到span元素之间存在诡异的间隙问题。这种间隙会导致一些布局上的问题，下面是几种解决的方法。 例子12345678&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123;display: inline-block; background-color: #ccc;&#125;&lt;/style&gt; 效果如下 在上述例子中，定义为inline-block的元素之间会产生间隙，那要是不定义为inline-block呢？12345678&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123; background-color: #ccc;&#125;&lt;/style&gt; 效果图 上面例子中，对span元素不做任何处理，依然会存在间隙，那如果把span元素放在一行显示会是怎么样的效果？123456&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123; background-color: #ccc;&#125;&lt;/style&gt; 效果图 可以发现，span元素之间的空隙消失了。说明这个间隙是由换行或者回车导致的，只要把标签写成一行就不会出现间隙，但是这种方法不太可靠，常常会因为一些因素失效。下面介绍一下几种写法：写法1：123&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 写法2：12345&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt; span元素&lt;/span&gt;&lt;span&gt; span元素&lt;/span&gt;&lt;/div&gt; 写法3：利用HTML注释标签12345&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 写法4：取消标签闭合12345&lt;div id="demo"&gt; &lt;span&gt;span元素 &lt;span&gt;span元素 &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 把span结束标签去掉，但需注意最后一个标签需要闭合。 写法5：把父级的font-size设为0,在子元素上设置相应的字体大小123456789&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo &#123;font-size:0;&#125; #demo span &#123; background-color: #ccc;font-size:14px;&#125;&lt;/style&gt; 对于Chrome, 其默认有最小字体大小限制，考虑到兼容性，需要取消字体大小限制，这样写：123456789&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo &#123;font-size:0;-webkit-text-size-adjust:none;&#125; #demo span &#123; background-color: #ccc;font-size:14px;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解決某些手机（移动端）无法触发touchend事件]]></title>
    <url>%2F2017%2F12%2F11%2Ftouch%2F</url>
    <content type="text"><![CDATA[开发移动端项目，虽然不用兼容头疼的IE浏览器，但是面对市场上各款手机兼容问题，也是一个持久战。这篇主要讲touch事件的兼容问题。 解決某些手机（移动端）无法触发touchend事件触屏事件的基本过程js的触屏事件，主要有三个事件：touchstart，touchmove，touchend。 这三个事件最重要的属性是 pageX和 pageY，表示X坐标，Y坐标。touchstart=在触摸开始时触发事件touchend=在触摸结束时触发事件touchmove=这个事件比较奇怪，按道理在触摸到过程中不断激发这个事件才对，但是在我的 Android 1.5 中，在 touchstart 激发后激发一次，然后剩余的都和 touchend 差不多同时激发。 而在我做的一个项目中，在某些手机上会出现不能触发touchend事件。 部分代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function listSlideChange(options) &#123; var delObj = options.find('.cheque-sign-row'), touchStartX = 0, touchMoveX = 0, touchSlideValue = 0, touchStartY = 0, touchMoveY = 0, touchSlideValue2 = 0, boxWidth = 0; for(var i = 0; i &lt; delObj.length; i++) &#123; (function(i) &#123; delObj.eq(i).off("touchstart.touch").on('touchstart.touch', function(e) &#123; moveFlag = false; var e = e || window.event; touchStartX = e.originalEvent.changedTouches[0].pageX; touchStartY = e.originalEvent.changedTouches[0].pageY; &#125;); delObj.eq(i).off("touchmove.touch").on('touchmove.touch', function(e) &#123; if ($(this).hasClass("disabled")) &#123; return false; &#125; var e = e || window.event; boxWidth = parseInt($('.transfer-plan-change').width()); var touchMoveX = e.originalEvent.changedTouches[0].pageX; touchSlideValue = touchStartX - touchMoveX; var touchMoveY = e.originalEvent.changedTouches[0].pageY; touchSlideValue2 = touchStartY - touchMoveY; if(Math.abs(touchSlideValue2)&lt;Math.abs(touchSlideValue))&#123; if(isSlideflag) &#123; $(delObj).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; &#125; else &#123; if(touchSlideValue &gt; 0 &amp;&amp; touchSlideValue &lt; boxWidth) &#123; $(this).css('left', -touchSlideValue); &#125; else if(touchSlideValue &gt; boxWidth) &#123; $(this).css('left', -boxWidth); &#125; else &#123; $(this).css('left', '0'); touchSlideValue = 0; &#125; &#125; moveFlag = true; &#125; &#125;); delObj.eq(i).off("touchend.touch").on('touchend.touch', function(e) &#123; if ($(this).hasClass("disabled")) &#123; return false; &#125; var e = e || window.event; if(moveFlag) &#123; if(touchSlideValue &gt; 60) &#123; $(this).stop().animate(&#123; 'left': -boxWidth &#125;, 200); isSlideflag = true; &#125; else &#123; $(this).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; isSlideflag = false; &#125; &#125; else &#123; if(touchSlideValue === 0) &#123; showChequeList($(this).find(".cheque-sign-arrow")); &#125; else &#123; $(delObj).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; isSlideflag = false; &#125; &#125; &#125;); &#125;)(i) &#125;&#125; 这是移动端最常见的功能，手指向左滑显示删除按钮。当你滑的比较少的距离，touchend时会隐藏这个删除按钮，只有你滑动到一定距离的时候，才会把整个删除按钮显示出来。而在某些手机上无法触发touchend事件，导致出现一半的按钮。 解决方法 只要在 touchstart 的时候调用下 event.preventDefault(); 即可让其他事件都正常被触发了!]]></content>
      <categories>
        <category>mobile</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[冒泡事件和默认事件]]></title>
    <url>%2F2017%2F02%2F16%2F%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[浅淡事件冒泡和默认事件 如何使用jQuery阻止事件冒泡和默认事件什么是事件冒泡？事件从事件目标开始，往上冒泡直到页面上的最上一级标签。（这与事件捕获顺序相反） 123456789101112131415161718&lt;div id="content"&gt; 外层div元素 &lt;span&gt;内层span元素&lt;/span&gt; 外层div元素&lt;/div&gt;&lt;div id="msg"&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $("#content").bind("click",function(e)&#123; var txt=$("#msg").html()+"&lt;p&gt;外层div元素被点击&lt;/p&gt;"; $("#msg").html(txt); &#125;); $("span").bind("click",function(e)&#123; var txt=$("#msg").html()+"&lt;p&gt;内层span元素被点击&lt;/p&gt;"; $("#msg").html(txt); &#125;);&#125;)&lt;/script&gt; 当点击span元素时会触发click事件,显示内层span元素被点击，同时因为事件冒泡，会触发content元素绑定的事件。 为什么要阻止事件冒泡呢？当某个DOM节点绑定了某事件监听器时，本来是想该DOM节点触发事件，才来执行某种操作。结果是该节点的某后代节点触发某事件，由于事件冒泡，该DOM节点事件也会触发，执行了该绑定事件的操作，这样就违背了最初的本意。 ###如何阻止事件冒泡？1234567891011121314&lt;style&gt; .box1&#123; height:200px; width:600px; margin:0 auto; border:1px solid #000; &#125; .box1 a&#123; display:block; height:50%; width:50%; background:red; &#125;&lt;/style&gt; 123456789101112&lt;body&gt; &lt;div class="box1"&gt; &lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1");//不阻止事件冒泡会打印1 ，页面跳转 &#125;) &#125;)&lt;/script&gt; 当点击a元素时，触发a本身的事件，同时也会触发父级绑定的click事件 12345678910&lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; e.stopPropagation();//不会打印a,但是页面会跳转 &#125;) &#125;)&lt;/script&gt; 阻止了冒泡事件，点击a元素时，不会触发父级box1的绑定事件。但是会执行a的默认事件（跳转到百度页面） 12345678910 &lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; e.preventDefault();//页面不会跳转，但是会打印出1 &#125;) &#125;)&lt;/script&gt; 阻止了a的默认事件，页面不会跳转，但是会触发父级的绑定事件 12345678910&lt;script&gt;$(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; return false;//不会打印1,页面不会跳转 &#125;)&#125;)&lt;/script&gt; 同时阻止了冒泡事件和默认事件，你也可以把return false替换成e.preventDefault()和e.stopPropagation();]]></content>
      <categories>
        <category>jquery</category>
      </categories>
  </entry>
</search>
