<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[解決某些手机（移动端）无法触发touchend事件]]></title>
    <url>%2F2017%2F12%2F11%2Ftouch%2F</url>
    <content type="text"><![CDATA[解決某些手机（移动端）无法触发touchend事件触屏事件的基本过程js的触屏事件，主要有三个事件：touchstart，touchmove，touchend。这三个事件最重要的属性是 pageX和 pageY，表示X坐标，Y坐标。touchstart=在触摸开始时触发事件touchend=在触摸结束时触发事件touchmove=这个事件比较奇怪，按道理在触摸到过程中不断激发这个事件才对，但是在我的 Android 1.5 中，在 touchstart 激发后激发一次，然后剩余的都和 touchend 差不多同时激发。 而在我做的一个项目中，在某些手机上会出现不能触发touchend事件。 部分代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function listSlideChange(options) &#123; var delObj = options.find('.cheque-sign-row'), touchStartX = 0, touchMoveX = 0, touchSlideValue = 0, touchStartY = 0, touchMoveY = 0, touchSlideValue2 = 0, boxWidth = 0; for(var i = 0; i &lt; delObj.length; i++) &#123; (function(i) &#123; delObj.eq(i).off("touchstart.touch").on('touchstart.touch', function(e) &#123; moveFlag = false; var e = e || window.event; touchStartX = e.originalEvent.changedTouches[0].pageX; touchStartY = e.originalEvent.changedTouches[0].pageY; &#125;); delObj.eq(i).off("touchmove.touch").on('touchmove.touch', function(e) &#123; if ($(this).hasClass("disabled")) &#123; return false; &#125; var e = e || window.event; boxWidth = parseInt($('.transfer-plan-change').width()); var touchMoveX = e.originalEvent.changedTouches[0].pageX; touchSlideValue = touchStartX - touchMoveX; var touchMoveY = e.originalEvent.changedTouches[0].pageY; touchSlideValue2 = touchStartY - touchMoveY; if(Math.abs(touchSlideValue2)&lt;Math.abs(touchSlideValue))&#123; if(isSlideflag) &#123; $(delObj).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; &#125; else &#123; if(touchSlideValue &gt; 0 &amp;&amp; touchSlideValue &lt; boxWidth) &#123; $(this).css('left', -touchSlideValue); &#125; else if(touchSlideValue &gt; boxWidth) &#123; $(this).css('left', -boxWidth); &#125; else &#123; $(this).css('left', '0'); touchSlideValue = 0; &#125; &#125; moveFlag = true; &#125; &#125;); delObj.eq(i).off("touchend.touch").on('touchend.touch', function(e) &#123; if ($(this).hasClass("disabled")) &#123; return false; &#125; var e = e || window.event; if(moveFlag) &#123; if(touchSlideValue &gt; 60) &#123; $(this).stop().animate(&#123; 'left': -boxWidth &#125;, 200); isSlideflag = true; &#125; else &#123; $(this).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; isSlideflag = false; &#125; &#125; else &#123; if(touchSlideValue === 0) &#123; showChequeList($(this).find(".cheque-sign-arrow")); &#125; else &#123; $(delObj).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; isSlideflag = false; &#125; &#125; &#125;); &#125;)(i) &#125;&#125; 这是移动端最常见的功能，手指向左滑显示删除按钮。当你滑的比较少的距离，touchend时会隐藏这个删除按钮，只有你滑动到一定距离的时候，才会把整个删除按钮显示出来。而在某些手机上无法触发touchend事件，导致出现一半的按钮。 解决方法 只要在 touchstart 的时候调用下 event.preventDefault(); 即可让其他事件都正常被触发了!]]></content>
      <categories>
        <category>mobile</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[冒泡事件和默认事件]]></title>
    <url>%2F2017%2F02%2F16%2F%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[如何使用jQuery阻止事件冒泡和默认事件什么是事件冒泡？事件从事件目标开始，往上冒泡直到页面上的最上一级标签。（这与事件捕获顺序相反）123456789101112131415161718&lt;div id="content"&gt; 外层div元素 &lt;span&gt;内层span元素&lt;/span&gt; 外层div元素&lt;/div&gt;&lt;div id="msg"&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $("#content").bind("click",function(e)&#123; var txt=$("#msg").html()+"&lt;p&gt;外层div元素被点击&lt;/p&gt;"; $("#msg").html(txt); &#125;); $("span").bind("click",function(e)&#123; var txt=$("#msg").html()+"&lt;p&gt;内层span元素被点击&lt;/p&gt;"; $("#msg").html(txt); &#125;);&#125;)&lt;/script&gt; 当点击span元素时会触发click事件,显示内层span元素被点击，同时因为事件冒泡，会触发content元素绑定的事件。 为什么要阻止事件冒泡呢？当某个DOM节点绑定了某事件监听器时，本来是想该DOM节点触发事件，才来执行某种操作。结果是该节点的某后代节点触发某事件，由于事件冒泡，该DOM节点事件也会触发，执行了该绑定事件的操作，这样就违背了最初的本意。 ###如何阻止事件冒泡？1234567891011121314&lt;style&gt; .box1&#123; height:200px; width:600px; margin:0 auto; border:1px solid #000; &#125; .box1 a&#123; display:block; height:50%; width:50%; background:red; &#125;&lt;/style&gt; 123456789101112&lt;body&gt; &lt;div class="box1"&gt; &lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1");//不阻止事件冒泡会打印1 ，页面跳转 &#125;) &#125;)&lt;/script&gt; 当点击a元素时，触发a本身的事件，同时也会触发父级绑定的click事件 12345678910&lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; e.stopPropagation();//不会打印a,但是页面会跳转 &#125;) &#125;)&lt;/script&gt; 阻止了冒泡事件，点击a元素时，不会触发父级box1的绑定事件。但是会执行a的默认事件（跳转到百度页面） 12345678910 &lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; e.preventDefault();//页面不会跳转，但是会打印出1 &#125;) &#125;)&lt;/script&gt; 阻止了a的默认事件，页面不会跳转，但是会触发父级的绑定事件 12345678910&lt;script&gt;$(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; return false;//不会打印1,页面不会跳转 &#125;)&#125;)&lt;/script&gt; 同时阻止了冒泡事件和默认事件，你也可以把return false替换成e.preventDefault()和e.stopPropagation();]]></content>
      <categories>
        <category>jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web前端常见面题]]></title>
    <url>%2F2017%2F01%2F19%2Fweb%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一些常见的前端面试题 Doctype作用？标准模式与兼容模式各有什么区别?（1）&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。（2）标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。]]></content>
  </entry>
</search>
