<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[function]]></title>
    <url>%2F2017%2F12%2F20%2Ffunction%2F</url>
    <content type="text"><![CDATA[此篇粗略的讲解下变量/函数声明提升。 ###什么是变量提升呢？正如字面意思，就是把定义在后面的变量或函数，提升到前面来使用。变量提升，简单来说，就是把定义的变量提升到一块作用域当中（或者说一个函数）顶端的位置，需要注意的是，变量提升，只是提示变量的声明，并不会将变量的赋值一同提升上来。比如下面代码12345(function()&#123; var a = 1; var b = 2; var c = 3;&#125;)() 我们在函数中定义了3个变量，而实际上，相当于这种写法123456(function()&#123; var a,b,c； a = 1; b = 2; c = 3;&#125;)() ###函数声明提升函数创建有两种方法函数声明语法：1234f('hello world!');function f(name) &#123; console.log(name);&#125; 运行上面的程序，控制台能打印出hello world!函数表达式语法：1234f('hello world!');var f = function(name) &#123; console.log(name);&#125; 运行上面的代码，会报错Uncaught ReferenceError: f is not defined(…)错误信息，显示f没有被定义。因为，函数声明有一个非常重要的特征：函数声明提升，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部。正是因为这个特征，所以可以把函数声明刚在调用它的语句后面。1234567var getName = function()&#123; console.log(2);&#125;function getName()&#123; console.log(1);&#125;getName(); 正如前面所说到的函数声明提升，函数声明function getName(){}的声明会被提前到顶部，而函数表达式var getName = function(){}则表现出变量提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到顶部，而变量的赋值依然保留在原来的位置。相当于12345678var getName;function getName()&#123; console.log(1);&#125;getName = function()&#123; console.log(2);&#125;getName(); //最终输出2 在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出2. 下面一题来测测你是否完全理解123456789101112131415function Foo()&#123; getName = function()&#123; alert(1) &#125;; return this;&#125;Foo.getName = function()&#123; alert(2) &#125;;Foo.prototype.getName = function()&#123; alert(3) &#125;;var getName = function()&#123; alert(4) &#125;;function getName()&#123; alert(5) &#125;;Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 答案1234567Foo.getName(); //2getName(); //4Foo().getName(); //1getName(); //1new Foo.getName(); //2new Foo().getName(); //3new new Foo().getName(); //3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[span间隙]]></title>
    <url>%2F2017%2F12%2F14%2Fspan%E9%97%B4%E9%9A%99%2F</url>
    <content type="text"><![CDATA[最近做移动端项目时，经常会碰到span元素之间存在诡异的间隙问题。这种间隙会导致一些布局上的问题，下面是几种解决的方法。 例子12345678&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123;display: inline-block; background-color: #ccc;&#125;&lt;/style&gt; 效果如下 在上述例子中，定义为inline-block的元素之间会产生间隙，那要是不定义为inline-block呢？12345678&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123; background-color: #ccc;&#125;&lt;/style&gt; 效果图 上面例子中，对span元素不做任何处理，依然会存在间隙，那如果把span元素放在一行显示会是怎么样的效果？123456&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo span &#123; background-color: #ccc;&#125;&lt;/style&gt; 效果图 可以发现，span元素之间的空隙消失了。说明这个间隙是由换行或者回车导致的，只要把标签写成一行就不会出现间隙，但是这种方法不太可靠，常常会因为一些因素失效。下面介绍一下几种写法：写法1：123&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 写法2：12345&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;span&gt; span元素&lt;/span&gt;&lt;span&gt; span元素&lt;/span&gt;&lt;/div&gt; 写法3：利用HTML注释标签12345&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 写法4：取消标签闭合12345&lt;div id="demo"&gt; &lt;span&gt;span元素 &lt;span&gt;span元素 &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt; 把span结束标签去掉，但需注意最后一个标签需要闭合。 写法5：把父级的font-size设为0,在子元素上设置相应的字体大小123456789&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo &#123;font-size:0;&#125; #demo span &#123; background-color: #ccc;font-size:14px;&#125;&lt;/style&gt; 对于Chrome, 其默认有最小字体大小限制，考虑到兼容性，需要取消字体大小限制，这样写：123456789&lt;div id="demo"&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt; &lt;span&gt;span元素&lt;/span&gt;&lt;/div&gt;&lt;style type="text/css"&gt; #demo &#123;font-size:0;-webkit-text-size-adjust:none;&#125; #demo span &#123; background-color: #ccc;font-size:14px;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo 的基本命令]]></title>
    <url>%2F2017%2F12%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start新建文章1$ hexo new "My New Post" #文件名称 More info: Writing 开启预览访问端口1$ hexo server #默认端口4000 如默认端口被占用，则 1$ hexo s -p 5000 More info: Server 清除缓存，网页正常情况下可以忽略此条命令1$ hexo clean 生成静态页面至public目录1$ hexo generate More info: Generating 将.deploy目录部署到GitHub1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[解決某些手机（移动端）无法触发touchend事件]]></title>
    <url>%2F2017%2F12%2F11%2Ftouch%2F</url>
    <content type="text"><![CDATA[开发移动端项目，虽然不用兼容头疼的IE浏览器，但是面对市场上各款手机兼容问题，也是一个持久战。这篇主要讲touch事件的兼容问题。 解決某些手机（移动端）无法触发touchend事件触屏事件的基本过程js的触屏事件，主要有三个事件：touchstart，touchmove，touchend。 这三个事件最重要的属性是 pageX和 pageY，表示X坐标，Y坐标。touchstart=在触摸开始时触发事件touchend=在触摸结束时触发事件touchmove=这个事件比较奇怪，按道理在触摸到过程中不断激发这个事件才对，但是在我的 Android 1.5 中，在 touchstart 激发后激发一次，然后剩余的都和 touchend 差不多同时激发。 而在我做的一个项目中，在某些手机上会出现不能触发touchend事件。 部分代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function listSlideChange(options) &#123; var delObj = options.find('.cheque-sign-row'), touchStartX = 0, touchMoveX = 0, touchSlideValue = 0, touchStartY = 0, touchMoveY = 0, touchSlideValue2 = 0, boxWidth = 0; for(var i = 0; i &lt; delObj.length; i++) &#123; (function(i) &#123; delObj.eq(i).off("touchstart.touch").on('touchstart.touch', function(e) &#123; moveFlag = false; var e = e || window.event; touchStartX = e.originalEvent.changedTouches[0].pageX; touchStartY = e.originalEvent.changedTouches[0].pageY; &#125;); delObj.eq(i).off("touchmove.touch").on('touchmove.touch', function(e) &#123; if ($(this).hasClass("disabled")) &#123; return false; &#125; var e = e || window.event; boxWidth = parseInt($('.transfer-plan-change').width()); var touchMoveX = e.originalEvent.changedTouches[0].pageX; touchSlideValue = touchStartX - touchMoveX; var touchMoveY = e.originalEvent.changedTouches[0].pageY; touchSlideValue2 = touchStartY - touchMoveY; if(Math.abs(touchSlideValue2)&lt;Math.abs(touchSlideValue))&#123; if(isSlideflag) &#123; $(delObj).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; &#125; else &#123; if(touchSlideValue &gt; 0 &amp;&amp; touchSlideValue &lt; boxWidth) &#123; $(this).css('left', -touchSlideValue); &#125; else if(touchSlideValue &gt; boxWidth) &#123; $(this).css('left', -boxWidth); &#125; else &#123; $(this).css('left', '0'); touchSlideValue = 0; &#125; &#125; moveFlag = true; &#125; &#125;); delObj.eq(i).off("touchend.touch").on('touchend.touch', function(e) &#123; if ($(this).hasClass("disabled")) &#123; return false; &#125; var e = e || window.event; if(moveFlag) &#123; if(touchSlideValue &gt; 60) &#123; $(this).stop().animate(&#123; 'left': -boxWidth &#125;, 200); isSlideflag = true; &#125; else &#123; $(this).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; isSlideflag = false; &#125; &#125; else &#123; if(touchSlideValue === 0) &#123; showChequeList($(this).find(".cheque-sign-arrow")); &#125; else &#123; $(delObj).stop().animate(&#123; 'left': '0' &#125;, 200); touchSlideValue = 0; isSlideflag = false; &#125; &#125; &#125;); &#125;)(i) &#125;&#125; 这是移动端最常见的功能，手指向左滑显示删除按钮。当你滑的比较少的距离，touchend时会隐藏这个删除按钮，只有你滑动到一定距离的时候，才会把整个删除按钮显示出来。而在某些手机上无法触发touchend事件，导致出现一半的按钮。 解决方法 只要在 touchstart 的时候调用下 event.preventDefault(); 即可让其他事件都正常被触发了!]]></content>
      <categories>
        <category>mobile</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[冒泡事件和默认事件]]></title>
    <url>%2F2017%2F02%2F16%2F%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[浅淡事件冒泡和默认事件 如何使用jQuery阻止事件冒泡和默认事件什么是事件冒泡？事件从事件目标开始，往上冒泡直到页面上的最上一级标签。（这与事件捕获顺序相反） 123456789101112131415161718&lt;div id="content"&gt; 外层div元素 &lt;span&gt;内层span元素&lt;/span&gt; 外层div元素&lt;/div&gt;&lt;div id="msg"&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $("#content").bind("click",function(e)&#123; var txt=$("#msg").html()+"&lt;p&gt;外层div元素被点击&lt;/p&gt;"; $("#msg").html(txt); &#125;); $("span").bind("click",function(e)&#123; var txt=$("#msg").html()+"&lt;p&gt;内层span元素被点击&lt;/p&gt;"; $("#msg").html(txt); &#125;);&#125;)&lt;/script&gt; 当点击span元素时会触发click事件,显示内层span元素被点击，同时因为事件冒泡，会触发content元素绑定的事件。 为什么要阻止事件冒泡呢？当某个DOM节点绑定了某事件监听器时，本来是想该DOM节点触发事件，才来执行某种操作。结果是该节点的某后代节点触发某事件，由于事件冒泡，该DOM节点事件也会触发，执行了该绑定事件的操作，这样就违背了最初的本意。 ###如何阻止事件冒泡？1234567891011121314&lt;style&gt; .box1&#123; height:200px; width:600px; margin:0 auto; border:1px solid #000; &#125; .box1 a&#123; display:block; height:50%; width:50%; background:red; &#125;&lt;/style&gt; 123456789101112&lt;body&gt; &lt;div class="box1"&gt; &lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1");//不阻止事件冒泡会打印1 ，页面跳转 &#125;) &#125;)&lt;/script&gt; 当点击a元素时，触发a本身的事件，同时也会触发父级绑定的click事件 12345678910&lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; e.stopPropagation();//不会打印a,但是页面会跳转 &#125;) &#125;)&lt;/script&gt; 阻止了冒泡事件，点击a元素时，不会触发父级box1的绑定事件。但是会执行a的默认事件（跳转到百度页面） 12345678910 &lt;script&gt; $(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; e.preventDefault();//页面不会跳转，但是会打印出1 &#125;) &#125;)&lt;/script&gt; 阻止了a的默认事件，页面不会跳转，但是会触发父级的绑定事件 12345678910&lt;script&gt;$(function()&#123; $(".box1").click(function()&#123; console.log("1"); &#125;) $(".box1 a").click(function(e)&#123; return false;//不会打印1,页面不会跳转 &#125;)&#125;)&lt;/script&gt; 同时阻止了冒泡事件和默认事件，你也可以把return false替换成e.preventDefault()和e.stopPropagation();]]></content>
      <categories>
        <category>jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web前端常见面题]]></title>
    <url>%2F2017%2F01%2F19%2Fweb%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一些常见的前端面试题 Doctype作用？标准模式与兼容模式各有什么区别?（1）&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。（2）标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。]]></content>
  </entry>
</search>
